<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mokorotlo (Basotho Hat) — Canvas Drawn</title>
<style>
  :root{
    --bg:#f6f4ee;
  }
  html,body{height:100%;margin:0;background:var(--bg);font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;color:#222}
  .wrap{min-height:100%;display:grid;place-items:center;padding:20px}
  .card{width:min(1100px,96vw);background:#fff;border-radius:16px;box-shadow:0 12px 28px rgba(0,0,0,.08);padding:14px}
  h1{font-size:1.05rem;margin:6px 8px 12px}
  .stage{width:100%;aspect-ratio: 16 / 10;border-radius:12px;overflow:hidden;background:radial-gradient(1200px 520px at 50% 110%, #ece7db, #faf9f3 55%, #ffffff)}
  canvas{width:100%;height:100%;display:block}
  .hint{color:#666;font-size:.92rem;margin:10px 8px 4px}
</style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>Mokorotlo (Basotho Straw Hat) — Drawn with JavaScript (Canvas)</h1>
      <div class="stage">
        <canvas id="mokorotlo"></canvas>
      </div>
      <p class="hint">Canvas only: no images, no SVG. Resize the window—the drawing stays sharp.</p>
    </div>
  </div>

<script>
(() => {
  /*** CONFIG (tweak if you want small proportion changes) ***/
  const BASE_W = 1000, BASE_H = 700;       // virtual design space
  const COLORS = {
    straw1: '#efd9a6', // light straw
    straw2: '#d8bd7d', // mid straw
    straw3: '#b68949', // deep straw
    straw4: '#8a6a35', // dark straw (lines/shadows)
    accent: '#3b2a16', // dark raffia/finial
    shadow: 'rgba(0,0,0,0.12)'
  };

  const canvas = document.getElementById('mokorotlo');
  const ctx = canvas.getContext('2d');

  // Fit canvas to CSS size at device pixel ratio
  function fitCanvas() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const { width, height } = canvas.getBoundingClientRect();
    canvas.width = Math.max(2, Math.floor(width * dpr));
    canvas.height = Math.max(2, Math.floor(height * dpr));
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // reset to CSS pixels
    draw();
  }

  // Helper: draw ellipse path
  function ellipsePath(ctx, cx, cy, rx, ry) {
    ctx.beginPath();
    ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2);
  }

  // Cone path (steep straw cone)
  function conePath(ctx) {
    ctx.beginPath();
    // This shape matches a steep, handwoven cone
    ctx.moveTo(500, 120);
    ctx.bezierCurveTo(468, 195, 428, 270, 385, 350);
    ctx.bezierCurveTo(370, 380, 375, 400, 500, 400);
    ctx.bezierCurveTo(625, 400, 630, 380, 615, 350);
    ctx.bezierCurveTo(572, 270, 532, 195, 500, 120);
    ctx.closePath();
  }

  // Create a simple diamond pattern as a CanvasPattern
  function createDiamondPattern() {
    const pw = 22, ph = 14;
    const p = document.createElement('canvas');
    p.width = pw; p.height = ph;
    const pc = p.getContext('2d');
    pc.strokeStyle = COLORS.accent;
    pc.globalAlpha = 0.6;
    pc.lineWidth = 1.4;
    pc.beginPath();
    // Diamond centered in tile
    pc.moveTo(11, 0);
    pc.lineTo(22, 7);
    pc.lineTo(11, 14);
    pc.lineTo(0, 7);
    pc.closePath();
    pc.stroke();
    pc.globalAlpha = 1;
    return ctx.createPattern(p, 'repeat');
  }

  // Fine diagonal weave impressions pattern (soft lines)
  function drawWeaveDiagonals(ctx, bbox, alpha = 0.18) {
    const { x, y, w, h } = bbox;
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.strokeStyle = COLORS.straw4;
    ctx.lineWidth = 1;

    // Left-leaning
    for (let i = -h; i < w + h; i += 12) {
      ctx.beginPath();
      ctx.moveTo(x + i, y + h);
      ctx.lineTo(x + i + h, y);
      ctx.stroke();
    }
    // Right-leaning (lighter)
    ctx.globalAlpha = alpha * 0.7;
    for (let i = -h; i < w + h; i += 12) {
      ctx.beginPath();
      ctx.moveTo(x + i, y);
      ctx.lineTo(x + i + h, y + h);
      ctx.stroke();
    }
    ctx.restore();
  }

  // Subtle horizontal arcs to imply round straw courses
  function drawWeaveArcs(ctx) {
    ctx.save();
    ctx.strokeStyle = COLORS.straw4;
    ctx.globalAlpha = 0.22;
    ctx.lineWidth = 2;

    ctx.beginPath();
    ctx.moveTo(425, 275);
    ctx.bezierCurveTo(500, 262, 500, 262, 575, 275);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(410, 305);
    ctx.bezierCurveTo(500, 290, 500, 290, 590, 305);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(400, 332);
    ctx.bezierCurveTo(500, 315, 500, 315, 600, 332);
    ctx.stroke();

    ctx.restore();
  }

  // Main draw routine in a normalized coordinate system
  function draw() {
    // Fit the BASE_W x BASE_H design into canvas CSS size
    const cssW = canvas.getBoundingClientRect().width;
    const cssH = canvas.getBoundingClientRect().height;

    // Clear
    ctx.clearRect(0, 0, cssW, cssH);

    // Compute scale and centering
    const sx = cssW / BASE_W;
    const sy = cssH / BASE_H;
    const s = Math.min(sx, sy);
    const offsetX = (cssW - BASE_W * s) / 2;
    const offsetY = (cssH - BASE_H * s) / 2;

    ctx.save();
    ctx.translate(offsetX, offsetY);
    ctx.scale(s, s);

    // ===== Ground shadow =====
    ctx.save();
    ctx.fillStyle = COLORS.shadow;
    ellipsePath(ctx, 500, 560, 270, 28);
    ctx.fill();
    ctx.restore();

    // ===== Brim (large oval) =====
    // Fill gradient across the brim
    const brimGrad = ctx.createLinearGradient(160, 520, 840, 560);
    brimGrad.addColorStop(0.00, COLORS.straw1);
    brimGrad.addColorStop(0.45, COLORS.straw2);
    brimGrad.addColorStop(1.00, COLORS.straw3);

    ctx.save();
    // Brim base
    ellipsePath(ctx, 500, 520, 360, 88);
    ctx.fillStyle = brimGrad;
    ctx.fill();

    // Brim stroke
    ctx.lineWidth = 4;
    ctx.strokeStyle = COLORS.straw4;
    ctx.stroke();

    // Rim highlight (top arc)
    const rimGrad = ctx.createLinearGradient(500, 432, 500, 608);
    // transparent to white for upper shine
    ctx.save();
    ctx.clip();
    ctx.globalAlpha = 0.45;
    ctx.lineWidth = 10;
    ctx.strokeStyle = '#ffffff';
    ctx.beginPath();
    ctx.ellipse(500, 520, 360, 88, 0, Math.PI * 0.85, Math.PI * 0.15, false);
    ctx.stroke();
    ctx.restore();

    // Inner shadow where cone meets brim
    ctx.globalAlpha = 1;
    ctx.fillStyle = 'rgba(0,0,0,0.08)';
    ellipsePath(ctx, 500, 505, 230, 52);
    ctx.fill();

    // Side darkening to hint denser weave/upturn
    ctx.fillStyle = 'rgba(0,0,0,0.10)';
    ctx.beginPath();
    ctx.moveTo(160, 520);
    ctx.bezierCurveTo(210, 530, 250, 575, 250, 590);
    ctx.bezierCurveTo(200, 585, 170, 555, 160, 520);
    ctx.closePath();
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(840, 520);
    ctx.bezierCurveTo(790, 530, 750, 575, 750, 590);
    ctx.bezierCurveTo(800, 585, 830, 555, 840, 520);
    ctx.closePath();
    ctx.fill();
    ctx.restore();

    // ===== Cone (main straw body) =====
    // Cone fill gradient (vertical)
    const coneGrad = ctx.createLinearGradient(500, 120, 500, 400);
    coneGrad.addColorStop(0.00, COLORS.straw1);
    coneGrad.addColorStop(0.55, COLORS.straw2);
    coneGrad.addColorStop(1.00, COLORS.straw3);

    ctx.save();
    conePath(ctx);
    ctx.fillStyle = coneGrad;
    ctx.fill();

    // Cone outline
    ctx.lineWidth = 3;
    ctx.strokeStyle = COLORS.straw4;
    ctx.stroke();

    // Subtle diagonal weave + arcs inside cone (clipped)
    ctx.save();
    conePath(ctx);
    ctx.clip();

    // Draw diagonal weave impressions
    drawWeaveDiagonals(ctx, { x: 360, y: 140, w: 280, h: 260 }, 0.18);
    // Horizontal arcs
    drawWeaveArcs(ctx);

    // Right-side highlight for directional light
    ctx.globalAlpha = 0.08;
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.moveTo(520, 155);
    ctx.bezierCurveTo(560, 235, 592, 297, 610, 340);
    ctx.bezierCurveTo(620, 362, 602, 392, 500, 392);
    ctx.bezierCurveTo(555, 332, 550, 238, 520, 155);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
    ctx.restore();

    // ===== Decorative band (diamond lattice ring) =====
    ctx.save();
    // Create ring clip using even-odd rule: outer ellipse minus inner ellipse
    ctx.beginPath();
    ctx.ellipse(500, 340, 185, 48, 0, 0, Math.PI * 2);
    ctx.ellipse(500, 340, 185, 32, 0, 0, Math.PI * 2);
    // Clip to ring
    if (typeof ctx.clip === 'function') {
      try { ctx.clip('evenodd'); } catch(e) { // fallback if evenodd not supported
        // Fallback: clip to outer, then punch inner with destination-out
        ctx.save();
        ctx.beginPath();
        ctx.ellipse(500, 340, 185, 48, 0, 0, Math.PI * 2);
        ctx.clip();
        // Paint pattern
        ctx.fillStyle = createDiamondPattern();
        ctx.globalAlpha = 0.95;
        ctx.fillRect(500-220, 340-62, 440, 124);
        // Punch inner
        ctx.globalCompositeOperation = 'destination-out';
        ctx.beginPath();
        ctx.ellipse(500, 340, 185, 32, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
        // Draw edges and continue
        ctx.globalCompositeOperation = 'source-over';
        ctx.strokeStyle = COLORS.accent;
        ctx.globalAlpha = 0.35;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.ellipse(500, 340, 185, 48, 0, 0, Math.PI * 2);
        ctx.stroke();
        ctx.globalAlpha = 0.28;
        ctx.beginPath();
        ctx.ellipse(500, 340, 185, 32, 0, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
        // Skip the even-odd path below
        drawFinial(); // draw finial and exit
        ctx.restore();
        return;
      }
    }

    // Fill the ring with a repeated diamond pattern
    ctx.fillStyle = createDiamondPattern();
    ctx.globalAlpha = 0.95;
    // Fill a rectangle covering the band area (clipped to the ring)
    ctx.fillRect(500-220, 340-62, 440, 124);

    // Band edge strokes for crispness
    ctx.globalAlpha = 1;
    ctx.strokeStyle = COLORS.accent;
    ctx.lineWidth = 2;
    ctx.globalAlpha = 0.35;
    ctx.beginPath();
    ctx.ellipse(500, 340, 185, 48, 0, 0, Math.PI * 2);
    ctx.stroke();
    ctx.globalAlpha = 0.28;
    ctx.beginPath();
    ctx.ellipse(500, 340, 185, 32, 0, 0, Math.PI * 2);
    ctx.stroke();

    ctx.restore();

    // ===== Finial (looped top) =====
    drawFinial();

    ctx.restore(); // end of normalized drawing

    // ---- Finial function (uses base coords) ----
    function drawFinial(){
      ctx.save();

      // Base ring under finial
      ctx.fillStyle = COLORS.straw1;
      ctx.strokeStyle = COLORS.straw4;
      ctx.lineWidth = 2;
      ellipsePath(ctx, 500, 144, 34, 12);
      ctx.fill();
      ctx.stroke();

      // Stem
      ctx.strokeStyle = COLORS.accent;
      ctx.lineWidth = 6;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(500, 140);
      ctx.bezierCurveTo(498, 118, 502, 104, 500, 90);
      ctx.stroke();

      // Looped head (ring) — stroke-only ellipse
      ctx.lineWidth = 8;
      ctx.beginPath();
      ctx.ellipse(500, 78, 18, 14, 0, 0, Math.PI * 2);
      ctx.stroke();

      // Small highlight on right side of loop
      ctx.strokeStyle = 'rgba(255,255,255,0.25)';
      ctx.lineWidth = 4;
      ctx.lineCap = 'round';
      ctx.beginPath();
      // Arc segment on right side
      const rx=14, ry=10;
      // Draw a short arc path by approximating with a curve
      ctx.moveTo(510, 66);
      ctx.bezierCurveTo(514, 70, 514, 86, 510, 90);
      ctx.stroke();

      ctx.restore();
    }
  }

  // Initial draw & on resize
  window.addEventListener('resize', fitCanvas);
  fitCanvas();
})();
</script>
</body>
</html>
