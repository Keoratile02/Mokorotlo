<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mokorotlo – Pic‑2 Style (Canvas only)</title>
<style>
  :root{ --bg:#f6f2e8; }
  html,body{height:100%;margin:0;background:var(--bg);font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;color:#222}
  .wrap{min-height:100%;display:grid;place-items:center;padding:18px}
  .card{width:min(1100px,96vw);background:#fff;border-radius:16px;box-shadow:0 12px 28px rgba(0,0,0,.08);padding:14px}
  h1{font-size:1.05rem;margin:6px 8px 12px}
  .stage{width:100%;aspect-ratio: 3 / 2;border-radius:12px;overflow:hidden;
    background:radial-gradient(1400px 620px at 50% 110%, #e9e2d3, #fbf8f1 55%, #ffffff)}
  canvas{width:100%;height:100%;display:block}
  .hint{color:#666;font-size:.92rem;margin:10px 8px 4px}
</style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>Mokorotlo — Pic‑2 look (LESOTHO text, red & green scallops, looped finial)</h1>
      <div class="stage">
        <canvas id="mokorotlo"></canvas>
      </div>
      <p class="hint">Pure Canvas (no images/SVG). Resize the window — the drawing stays crisp.</p>
    </div>
  </div>

<script>
(() => {
  /************ TUNABLE CONFIG (set to match Pic‑2) ************/
  const SIZE = { W: 900, H: 600 }; // virtual design space
  const C = {
    // Straw tones (warm, like photo)
    strawHi:  '#ecd09e',
    strawMd:  '#caa66a',
    strawLo:  '#a37843',
    strawLine:'#7a5d32',
    // Bands & text
    red:      '#b43b33',
    greenBand:'#1e4738',
    greenText:'#0e4635',
    // Finial + shadow
    finial:   '#6f5330',
    groundSh: 'rgba(0,0,0,0.13)'
  };

  // Geometry chosen to look like Pic‑2 (cone dominates; brim barely visible)
  const G = {
    cx: 450,
    coneTopY: 78,
    coneBaseY: 378,
    coneRxTop: 12,     // very narrow tip
    coneRxBase: 275,   // wide base -> cone looks stout like the photo
    coneRyBase: 56,    // vertical squash for base ellipse (perspective)

    // Band centerlines
    yText: 230,
    yRed:  282,
    yGreen:334,

    // Band ellipse radii as fractions of base radii
    scaleX: { text:0.62, red:0.79, green:0.93 },
    scaleY: { text:0.33, red:0.45, green:0.57 },

    // Scallops (count & outward amplitude)
    scallops: { red: 46, green: 50 },
    amp:      { red: 18, green: 22 }
  };

  const canvas = document.getElementById('mokorotlo');
  const ctx = canvas.getContext('2d');

  function fitCanvas(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const r = canvas.getBoundingClientRect();
    canvas.width  = Math.max(2, Math.floor(r.width  * dpr));
    canvas.height = Math.max(2, Math.floor(r.height * dpr));
    ctx.setTransform(dpr,0,0,dpr,0,0);
    draw();
  }

  /*********************** helpers ************************/
  const lerp = (a,b,t)=>a+(b-a)*t;

  function ellipsePath(cx,cy,rx,ry){
    ctx.beginPath(); ctx.ellipse(cx,cy,rx,ry,0,0,Math.PI*2);
  }

  function shade(hex, amt){ // amt -1..+1
    const h = hex.replace('#','');
    const r = parseInt(h.slice(0,2),16), g=parseInt(h.slice(2,4),16), b=parseInt(h.slice(4,6),16);
    const adj = v => Math.max(0,Math.min(255, Math.round(v + 255*amt)));
    return '#'+[adj(r),adj(g),adj(b)].map(v=>v.toString(16).padStart(2,'0')).join('');
  }

  function radiiAtY(y){
    const t = (y - G.coneTopY) / (G.coneBaseY - G.coneTopY);
    const rx = lerp(G.coneRxTop, G.coneRxBase, t);
    const ry = lerp(G.coneRxTop*0.7, G.coneRyBase, t);
    return {rx, ry};
  }

  /*********************** drawing ************************/
  function drawGroundShadow(){
    ctx.save();
    ctx.fillStyle = C.groundSh;
    ellipsePath(G.cx, G.coneBaseY + 34, 205, 20);
    ctx.fill();
    ctx.restore();
  }

  function drawBrimTiny(){
    // In Pic‑2 the brim is barely visible — just a thin lip under the cone
    const rx = G.coneRxBase * 1.01;
    const ry = G.coneRyBase * 0.72;
    const cy = G.coneBaseY + 1.5;
    const g = ctx.createLinearGradient(G.cx-rx,cy,G.cx+rx,cy);
    g.addColorStop(0, C.strawHi);
    g.addColorStop(0.5, C.strawMd);
    g.addColorStop(1, C.strawLo);
    ctx.save();
    ellipsePath(G.cx, cy, rx, ry);
    ctx.fillStyle = g; ctx.fill();
    ctx.globalAlpha = 0.55;
    ctx.lineWidth = 2; ctx.strokeStyle = C.strawLine; ctx.stroke();
    ctx.restore();
  }

  function drawCone(){
    // Build silhouette by sampling width from top to base (gives a realistic cone curve)
    const steps = 44;
    const L=[],R=[],Y=[];
    for(let i=0;i<=steps;i++){
      const y = lerp(G.coneTopY, G.coneBaseY, i/steps);
      const {rx} = radiiAtY(y);
      L.push([G.cx - rx, y]);
      R.push([G.cx + rx, y]);
      Y.push(y);
    }

    const grad = ctx.createLinearGradient(G.cx, G.coneTopY, G.cx, G.coneBaseY);
    grad.addColorStop(0.00, C.strawHi);
    grad.addColorStop(0.55, C.strawMd);
    grad.addColorStop(1.00, C.strawLo);

    ctx.save();
    ctx.beginPath();
    ctx.moveTo(L[0][0], L[0][1]);
    for(let i=1;i<L.length;i++) ctx.lineTo(L[i][0], L[i][1]);
    for(let i=R.length-1;i>=0;i--) ctx.lineTo(R[i][0], R[i][1]);
    ctx.closePath();
    ctx.fillStyle = grad; ctx.fill();

    // outline
    ctx.strokeStyle = C.strawLine; ctx.lineWidth = 2.4; ctx.stroke();

    // weave inside
    ctx.save(); ctx.clip();

    // diagonal cross‑hatch; denser near apex
    drawWeave({x:G.cx-G.coneRxBase, y:G.coneTopY, w:G.coneRxBase*2, h:G.coneBaseY-G.coneTopY},
              {gap:12, alpha:0.22});
    drawWeave({x:G.cx-G.coneRxBase, y:G.coneTopY, w:G.coneRxBase*2, h:(G.coneBaseY-G.coneTopY)*0.55},
              {gap:9, alpha:0.26});

    // gentle horizontal arcs (ring courses)
    ctx.strokeStyle = C.strawLine; ctx.globalAlpha = 0.2; ctx.lineWidth = 1.8;
    const arcs=[225,255,285,315];
    for(const y of arcs){
      ctx.beginPath();
      ctx.moveTo(G.cx-120,y);
      ctx.bezierCurveTo(G.cx,y-14,G.cx,y-14,G.cx+120,y);
      ctx.stroke();
    }

    // right‑side highlight to match lighting
    ctx.globalAlpha = 0.09; ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.moveTo(G.cx+22, 150);
    ctx.bezierCurveTo(G.cx+78, 232, G.cx+112, 292, G.cx+130, 332);
    ctx.bezierCurveTo(G.cx+140, 352, G.cx+118, 383, G.cx, 383);
    ctx.bezierCurveTo(G.cx+60, 328, G.cx+56, 232, G.cx+22, 150);
    ctx.closePath();
    ctx.fill();

    ctx.restore(); // clip
    ctx.restore();
  }

  function drawWeave(bbox, {gap, alpha}){
    const {x,y,w,h} = bbox;
    ctx.save();
    ctx.strokeStyle = C.strawLine; ctx.lineWidth = 1;

    // left‑leaning
    ctx.globalAlpha = alpha;
    for(let i=-h;i<w+h;i+=gap){
      ctx.beginPath(); ctx.moveTo(x+i, y+h); ctx.lineTo(x+i+h, y); ctx.stroke();
    }
    // right‑leaning lighter
    ctx.globalAlpha = alpha*0.7;
    for(let i=-h;i<w+h;i+=gap){
      ctx.beginPath(); ctx.moveTo(x+i, y); ctx.lineTo(x+i+h, y+h); ctx.stroke();
    }
    ctx.restore();
  }

  // Scalloped ring with “cut‑out” feel (matches Pic‑2 red/green bands)
  function drawScallopBand({cy, rxScale, ryScale, count, amp, color}){
    const rx = G.coneRxBase * rxScale;
    const ry = G.coneRyBase * ryScale;

    ctx.save();

    // shallow underlay to deepen color
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = color;
    ellipsePath(G.cx, cy, rx, ry); ctx.fill();

    ctx.globalAlpha = 1;
    const TWO = Math.PI*2, step = TWO / count;
    for(let i=0;i<count;i++){
      const a = i*step;
      // ellipse point & outward normal
      const px = G.cx + rx*Math.cos(a);
      const py = cy   + ry*Math.sin(a);
      const nx = Math.cos(a), ny = Math.sin(a);

      const qx = px + nx*amp;
      const qy = py + ny*amp;

      // outer petal
      ctx.beginPath();
      ctx.moveTo(px,py);
      ctx.quadraticCurveTo(px+(-ny)*amp*0.45, py+(nx)*amp*0.45, qx, qy);
      ctx.quadraticCurveTo(px+(ny)*amp*0.45,  py+(-nx)*amp*0.45, px, py);
      ctx.closePath();

      // fill with slight radial shading
      const rg = ctx.createRadialGradient(px,py,0,px,py,Math.max(10,amp));
      rg.addColorStop(0.0, shade(color, 0.10));
      rg.addColorStop(0.6, color);
      rg.addColorStop(1.0, shade(color,-0.28));
      ctx.fillStyle = rg; ctx.fill();

      // carve inner bite to get “looped” look
      ctx.save();
      ctx.globalCompositeOperation = 'destination-out';
      ctx.beginPath();
      ctx.ellipse(px+nx*amp*0.42, py+ny*amp*0.42, amp*0.52, amp*0.40, Math.atan2(ny,nx), 0, Math.PI*2);
      ctx.fill();
      ctx.restore();

      // edge line
      ctx.strokeStyle = shade(color,-0.36);
      ctx.lineWidth = 1.5; ctx.globalAlpha = 0.9; ctx.stroke();
      ctx.globalAlpha = 1;
    }

    // subtle band edges
    ctx.globalAlpha = 0.35; ctx.strokeStyle = shade(color,-0.35); ctx.lineWidth = 2;
    ellipsePath(G.cx, cy, rx, ry); ctx.stroke();
    ctx.globalAlpha = 0.25;
    ellipsePath(G.cx, cy, rx*0.965, ry*0.86); ctx.stroke();

    ctx.restore();
  }

  // Filled blocky “LESOTHO” on a near‑straight baseline
  function drawLesotho(){
    const text = 'LESOTHO';
    const cx = G.cx, cy = G.yText;
    const rx = G.coneRxBase * G.scaleX.text;
    const ry = G.coneRyBase * G.scaleY.text;

    // Rect‑based glyphs (100×80 box scaled) — keeps the block look from Pic‑2
    const GL = {
      'L': [[0,0,18,80],[0,62,60,18]],
      'E': [[0,0,18,80],[0,0,60,18],[0,31,48,18],[0,62,60,18]],
      'S': [[0,0,60,18],[0,0,18,40],[0,31,60,18],[42,40,18,40],[0,62,60,18]],
      'O': [[0,0,18,80],[42,0,18,80],[0,0,60,18],[0,62,60,18]],
      'T': [[0,0,66,18],[24,0,18,80]],
      'H': [[0,0,18,80],[42,0,18,80],[0,31,60,18]]
    };

    const span = Math.PI * 0.11;            // tiny curvature like the photo
    const a0 = -span/2 - Math.PI*0.01;      // slight tilt

    const advance = 66;                      // spacing
    const totalW  = (text.length-1)*advance + 60;
    const startX  = -totalW/2;

    ctx.save();
    ctx.fillStyle = C.greenText;
    ctx.lineJoin = 'miter'; ctx.lineCap = 'butt';

    for(let i=0;i<text.length;i++){
      const ch = text[i], rects = GL[ch];
      const xFront = startX + i*advance + 30;
      const t = (xFront - startX) / totalW;
      const a = a0 + t*span;

      const px = cx + rx*Math.cos(a);
      const py = cy + ry*Math.sin(a);
      const tang = Math.atan2(ry*Math.cos(a), -rx*Math.sin(a));

      // draw glyph filled, slightly squashed & sheared (cone perspective)
      ctx.save();
      ctx.translate(px, py);
      ctx.rotate(tang * 0.35); // keep almost straight
      ctx.transform(1, -0.10, 0, 0.95, 0, 0); // shearY, scaleY
      const s = 0.92, ox=-30, oy=-40;
      ctx.beginPath();
      for(const r of rects) ctx.rect(ox + r[0]*s, oy + r[1]*s, r[2]*s, r[3]*s);
      ctx.fill();
      ctx.restore();
    }
    ctx.restore();
  }

  function drawFinial(){
    ctx.save();
    // Base ring
    ctx.fillStyle = C.strawHi; ctx.strokeStyle = C.strawLine; ctx.lineWidth = 2;
    ellipsePath(G.cx, 140, 30, 10); ctx.fill(); ctx.stroke();

    // Stem
    ctx.strokeStyle = C.finial; ctx.lineWidth = 6; ctx.lineCap = 'round';
    ctx.beginPath(); ctx.moveTo(G.cx, 138);
    ctx.bezierCurveTo(G.cx-2,118, G.cx+2,106, G.cx, 92);
    ctx.stroke();

    // Messy loop bundle
    ctx.strokeStyle = C.finial; ctx.lineWidth = 5.2;
    const baseY = 124;
    const loops = [
      {dx:-18, w:18, h:28, rot:-0.1},
      {dx: 18, w:18, h:26, rot: 0.1},
      {dx: -6, w:20, h:32, rot: 0.02},
      {dx:  8, w:18, h:30, rot:-0.05},
      {dx:-12, w:14, h:22, rot: 0.12},
      {dx: 12, w:14, h:22, rot:-0.12},
    ];
    for(const L of loops){
      ctx.save(); ctx.translate(G.cx+L.dx, baseY); ctx.rotate(L.rot);
      ctx.beginPath(); ctx.ellipse(0,0,L.w,L.h,0,0,Math.PI*2); ctx.stroke();
      ctx.restore();
    }

    // Knot + tiny highlight
    ctx.beginPath(); ctx.arc(G.cx, 86, 8, 0, Math.PI*2);
    ctx.fillStyle = C.finial; ctx.fill();

    ctx.strokeStyle = 'rgba(255,255,255,0.22)'; ctx.lineWidth = 3.2;
    ctx.beginPath(); ctx.arc(G.cx+8, 78, 6, Math.PI*0.2, Math.PI*1.25); ctx.stroke();

    ctx.restore();
  }

  function drawBands(){
    // Red inner band
    drawScallopBand({
      cy: G.yRed,
      rxScale: G.scaleX.red,
      ryScale: G.scaleY.red,
      count: G.scallops.red,
      amp: G.amp.red,
      color: C.red
    });

    // Dark‑green outer band
    drawScallopBand({
      cy: G.yGreen,
      rxScale: G.scaleX.green,
      ryScale: G.scaleY.green,
      count: G.scallops.green,
      amp: G.amp.green,
      color: C.greenBand
    });
  }

  function draw(){
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;
    ctx.clearRect(0,0,w,h);

    // normalize to design space & center
    const sx = w / SIZE.W, sy = h / SIZE.H, s = Math.min(sx, sy);
    const ox = (w - SIZE.W*s)/2, oy = (h - SIZE.H*s)/2;
    ctx.save(); ctx.translate(ox, oy); ctx.scale(s, s);

    drawGroundShadow();
    drawBrimTiny();
    drawCone();
    drawBands();
    drawLesotho();
    drawFinial();

    ctx.restore();
  }

  window.addEventListener('resize', fitCanvas);
  fitCanvas();
})();
</script>
</body>
</html>
